# v0.96 Balance Implementation Plan

**Date:** November 26, 2025  
**Based on:** Comprehensive Analysis of 50 AI vs AI simulations  
**Goal:** Address critical balance issues identified in simulation data

---

## Table of Contents

1. [Buff AetherianVanguard & JadeCovenant](#1-buff-aetherianvanguard--jadecovenant)
2. [Fix Settler Escort Logic](#2-fix-settler-escort-logic)
3. [Nerf ScholarKingdoms](#3-nerf-scholarkingdoms)
4. [Increase Smaller Map Sizes](#4-increase-smaller-map-sizes)
5. [Randomize Civ Selection](#5-randomize-civ-selection)
6. [Add AI Razing Logic](#6-add-ai-razing-logic)
7. [Rebalance Army Unit Utilization](#7-rebalance-army-unit-utilization)

---

## 1. Buff AetherianVanguard & JadeCovenant

### Problem Analysis

Both civs have **0% win rate** because:
- Their unique wonders (Titan's Core, Jade Granary) require reaching Engine/Banner era + high production
- By the time they can build their wonder, ScholarKingdoms has already won via Progress
- Their wonders don't provide **early-game advantages** to compete

### Solution: Add Passive Bonuses

**Design Philosophy:** Give each civ a meaningful early-game passive that synergizes with their unique wonder.

#### AetherianVanguard — "The Vanguard"

**Current State:**
- Unique Building: Titan's Core (200 Production, Engine era, summons Titan)
- No passive bonus

**Proposed Changes:**

1. **New Passive: "Battle Hardened"**
   - All military units gain **+1 HP per era researched** (max +3 HP at Engine era)
   - Rationale: Helps units survive longer, synergizes with Titan's military focus
   
2. **Alternative Passive: "Forged in Fire"**
   - Units heal **+1 HP per turn** even outside friendly territory
   - Rationale: Enables aggressive expansion and sustained warfare

**Implementation:**
```typescript
// engine/src/core/constants.ts - Add to civ traits section or create new CIV_TRAITS constant
export const CIV_TRAITS = {
    AetherianVanguard: {
        passiveType: "BattleHardened",
        description: "+1 HP to all military units per era researched (max +3)",
    },
    // ...
};

// engine/src/game/rules.ts - Modify getUnitMaxHp or similar
function getUnitMaxHp(unit: Unit, player: Player): number {
    const baseHp = UNITS[unit.type].hp;
    if (player.civName === "AetherianVanguard") {
        const eraCount = countErasResearched(player); // 0-3 based on techs
        return baseHp + eraCount;
    }
    return baseHp;
}
```

#### JadeCovenant — "The Covenant"

**Current State:**
- Unique Building: Jade Granary (150 Production, Banner era, +1 Pop/city, -15% growth cost, +1 Food/city)
- No passive bonus

**Proposed Changes:**

1. **New Passive: "Bountiful Harvest"**
   - Cities start with **+5 stored Food** when founded
   - Rationale: Faster early expansion, synergizes with growth focus

2. **Alternative Passive: "Ancestral Wisdom"**
   - **-10% growth cost** baseline (stacks with Farmstead/Jade Granary)
   - Rationale: Directly supports their growth-focused playstyle

**Implementation:**
```typescript
// engine/src/game/actions/city.ts - Modify FoundCity action
if (player.civName === "JadeCovenant") {
    newCity.storedFood = 5; // Start with bonus food
}

// OR in engine/src/game/rules.ts - Modify getGrowthCost
function getGrowthCost(pop: number, hasFarmstead: boolean, hasJadeGranary: boolean, civName: string): number {
    let mult = 1.0;
    if (hasFarmstead) mult *= 0.9;
    if (hasJadeGranary) mult *= 0.85;
    if (civName === "JadeCovenant") mult *= 0.9; // Passive 10% reduction
    return Math.round(BASE_GROWTH_COST * getGrowthMultiplier(pop) * mult);
}
```

### Files to Modify

| File | Changes |
|------|---------|
| `engine/src/core/constants.ts` | Add `CIV_TRAITS` constant with passive definitions |
| `engine/src/game/rules.ts` | Add `getUnitMaxHp()` with civ check, modify `getGrowthCost()` |
| `engine/src/game/turn-lifecycle.ts` | Apply HP bonus on unit spawn, growth bonus on city found |
| `engine/src/game/actions/city.ts` | Apply starting food bonus for JadeCovenant |

---

## 2. Fix Settler Escort Logic

### Problem Analysis

**92.5% settler death rate** despite escort logic existing. Root causes:

1. **Order of Operations Bug:** `moveSettlersAndFound()` is called BEFORE `manageSettlerEscorts()`. Settlers move first, then escorts try to catch up — too late!

2. **`assessSettlerSafety()` Only Checks War Enemies:** The function checks `state.diplomacy?.[playerId]?.[p.id] === DiplomacyState.War`. But:
   - Peace can turn to war on enemy's turn
   - Enemies can attack immediately after declaring war

3. **Escort Distance Threshold Too Generous:** If escort is within 2 tiles, it doesn't move closer. But 2 tiles away can't intercept attackers.

4. **No Movement Coordination:** Settlers and escorts move independently. They should move together as a unit.

### Solution: Comprehensive Escort Fix

#### Step 1: Reorder Turn Sequence

```typescript
// engine/src/game/ai/turn-runner.ts - Current order (BROKEN):
state = moveSettlersAndFound(state, playerId);    // Settler moves alone
state = manageSettlerEscorts(state, playerId);     // Escort tries to catch up (too late!)

// Fixed order:
state = manageSettlerEscorts(state, playerId);     // Assign escorts FIRST
state = moveSettlersAndEscortsTogether(state, playerId); // Move together
```

#### Step 2: New `assessSettlerSafety()` Logic

```typescript
// engine/src/game/ai/units.ts
function assessSettlerSafety(
    settlerCoord: HexCoord,
    playerId: string,
    state: GameState
): { isSafe: boolean; needsEscort: boolean; threatLevel: "none" | "low" | "high" } {
    const ownedCities = state.cities.filter(c => c.ownerId === playerId);
    const isInFriendlyBorders = ownedCities.some(city =>
        hexDistance(settlerCoord, city.coord) <= 2
    );

    // Check ALL non-allied players, not just war enemies
    const potentialThreats = state.players
        .filter(p => p.id !== playerId && !p.isEliminated)
        .map(p => p.id);

    // Any military unit within 4 tiles is a threat (they can move 2 and attack)
    const nearbyEnemyUnits = state.units.filter(u =>
        potentialThreats.includes(u.ownerId) &&
        UNITS[u.type].domain !== "Civilian" &&
        hexDistance(settlerCoord, u.coord) <= 4
    );

    const warEnemyUnits = nearbyEnemyUnits.filter(u =>
        state.diplomacy?.[playerId]?.[u.ownerId] === DiplomacyState.War
    );

    const threatLevel = 
        warEnemyUnits.length > 0 ? "high" :
        nearbyEnemyUnits.length > 0 ? "low" : "none";

    // ALWAYS need escort outside friendly borders
    // Need escort if ANY enemy military is within 4 tiles
    const needsEscort = !isInFriendlyBorders || nearbyEnemyUnits.length > 0;
    const isSafe = isInFriendlyBorders && warEnemyUnits.length === 0;

    return { isSafe, needsEscort, threatLevel };
}
```

#### Step 3: Move Settler + Escort Together

```typescript
// engine/src/game/ai/units.ts - New function
export function moveSettlersAndEscortsTogether(state: GameState, playerId: string): GameState {
    let next = state;
    
    const settlers = next.units.filter(u => u.ownerId === playerId && u.type === UnitType.Settler);
    
    for (const settler of settlers) {
        const liveSettler = next.units.find(u => u.id === settler.id);
        if (!liveSettler || liveSettler.movesLeft <= 0) continue;
        
        const safety = assessSettlerSafety(liveSettler.coord, playerId, next);
        
        // Find assigned escort (should be same tile or adjacent)
        const escort = next.units.find(u =>
            u.ownerId === playerId &&
            UNITS[u.type].domain !== "Civilian" &&
            hexDistance(u.coord, liveSettler.coord) <= 1 &&
            u.movesLeft > 0
        );
        
        // If high threat and no escort adjacent, DON'T MOVE - wait for escort
        if (safety.threatLevel === "high" && !escort) {
            continue;
        }
        
        // Determine target (city site or escape route)
        const target = safety.threatLevel === "high" 
            ? findSafeRetreatTile(liveSettler.coord, playerId, next)
            : findBestCitySite(liveSettler.coord, playerId, next);
        
        if (!target) continue;
        
        // Move escort first (if exists and needs to move)
        if (escort && safety.needsEscort) {
            const escortPath = findPath(escort.coord, target, escort, next);
            if (escortPath.length > 0) {
                next = tryAction(next, {
                    type: "MoveUnit",
                    playerId,
                    unitId: escort.id,
                    to: escortPath[0]
                });
            }
        }
        
        // Then move settler
        const settlerPath = findPath(liveSettler.coord, target, liveSettler, next);
        if (settlerPath.length > 0) {
            // Check if destination is safe
            const destSafety = assessSettlerSafety(settlerPath[0], playerId, next);
            if (destSafety.threatLevel !== "high" || escort) {
                next = tryAction(next, {
                    type: "MoveUnit",
                    playerId,
                    unitId: liveSettler.id,
                    to: settlerPath[0]
                });
            }
        }
        
        // Try to found city if on valid tile
        // ... (existing founding logic)
    }
    
    return next;
}
```

#### Step 4: Improve Escort Assignment

```typescript
// engine/src/game/ai/units.ts - Improved manageSettlerEscorts
export function manageSettlerEscorts(state: GameState, playerId: string): GameState {
    let next = state;

    const settlers = next.units.filter(u => u.ownerId === playerId && u.type === UnitType.Settler);
    
    // ALL settlers need escorts (not just those in danger)
    const settlersNeedingEscorts = settlers.filter(settler => {
        // Check if already has adjacent escort
        const hasEscort = next.units.some(u =>
            u.ownerId === playerId &&
            u.id !== settler.id &&
            UNITS[u.type].domain !== "Civilian" &&
            hexDistance(u.coord, settler.coord) <= 1
        );
        return !hasEscort;
    });

    if (settlersNeedingEscorts.length === 0) return next;

    // Get available military units not already escorting or garrisoning
    const garrisonedCities = new Set(
        next.cities.filter(c => c.ownerId === playerId).map(c => hexToString(c.coord))
    );
    
    const militaryUnits = next.units.filter(u =>
        u.ownerId === playerId &&
        UNITS[u.type].domain !== "Civilian" &&
        u.movesLeft > 0 &&
        !garrisonedCities.has(hexToString(u.coord)) // Don't pull garrisons
    );

    const escortAssignments = new Map<string, string>();

    for (const settler of settlersNeedingEscorts) {
        const availableUnits = militaryUnits.filter(u => !escortAssignments.has(u.id));
        if (availableUnits.length === 0) break;

        // Prefer units that are close AND fast
        const scored = availableUnits.map(u => ({
            unit: u,
            score: -hexDistance(settler.coord, u.coord) + UNITS[u.type].move
        })).sort((a, b) => b.score - a.score);

        if (scored.length > 0) {
            escortAssignments.set(scored[0].unit.id, settler.id);
        }
    }

    // Move escorts to their settlers (must be adjacent, not 2 tiles away)
    for (const [escortId, settlerId] of escortAssignments.entries()) {
        const escort = next.units.find(u => u.id === escortId);
        const settler = next.units.find(u => u.id === settlerId);

        if (!escort || !settler || escort.movesLeft <= 0) continue;

        const distance = hexDistance(escort.coord, settler.coord);

        // Must be adjacent (distance 1), not just "within 2"
        if (distance <= 1) continue;

        // Path to settler's tile or adjacent
        const path = findPath(escort.coord, settler.coord, escort, next);
        if (path.length > 0) {
            next = tryAction(next, {
                type: "MoveUnit",
                playerId,
                unitId: escort.id,
                to: path[0]
            });
        }
    }

    return next;
}
```

### Files to Modify

| File | Changes |
|------|---------|
| `engine/src/game/ai/turn-runner.ts` | Reorder: escorts before settlers, combine movement |
| `engine/src/game/ai/units.ts` | Rewrite `assessSettlerSafety()`, `manageSettlerEscorts()`, add `moveSettlersAndEscortsTogether()` |

---

## 3. Nerf ScholarKingdoms

### Problem Analysis

**46% win rate** (vs expected ~17% with 6 civs). Root cause:

- **+1 Science per city at Pop ≥3** creates compounding advantage:
  - More science → faster techs → faster buildings → faster growth → more cities at Pop 3+ → more science
- They only need **2.3 avg cities** to win (lowest of all civs)
- **95.7% of wins are Progress** — they race to Grand Experiment before anyone can stop them

### Solution Options

#### Option A: Conditional Science Bonus (Recommended)

**Change:** +1 Science per city at Pop ≥3 → **+1 Science per city at Pop ≥5**

**Rationale:** 
- Pop 5 requires ~30-40 turns of growth (vs ~15-20 for Pop 3)
- Delays the science snowball to mid-game
- Still rewards their growth-focused strategy

**Implementation:**
```typescript
// engine/src/game/rules.ts - Modify getSciencePerTurn
const scholarBonus = player.civName === "ScholarKingdoms"
    ? cities.filter(c => c.pop >= 5).length  // Changed from 3 to 5
    : 0;
```

#### Option B: Diminishing Returns

**Change:** +1 Science per city at Pop ≥3 → **+1 Science for first 2 cities at Pop ≥3, then +0.5 (rounded down)**

**Rationale:**
- Caps the maximum bonus
- 4 cities at Pop 3 = +3 Science (not +4)
- Rewards early science but prevents runaway

**Implementation:**
```typescript
const qualifyingCities = cities.filter(c => c.pop >= 3).length;
const scholarBonus = player.civName === "ScholarKingdoms"
    ? Math.min(qualifyingCities, 2) + Math.floor(Math.max(0, qualifyingCities - 2) / 2)
    : 0;
```

#### Option C: Replace with Different Bonus

**Change:** Remove science bonus, add **-10% tech cost** instead

**Rationale:**
- Flat reduction doesn't compound
- Still helps with Progress victory
- More predictable balance

**Implementation:**
```typescript
// engine/src/game/rules.ts - Modify tech cost calculation
function getTechCost(techId: TechId, civName: string): number {
    const baseCost = TECHS[techId].cost;
    if (civName === "ScholarKingdoms") {
        return Math.round(baseCost * 0.9);
    }
    return baseCost;
}
```

### Recommendation

**Option A (Pop ≥5)** is the cleanest solution:
- Minimal code change
- Preserves the civ's identity
- Delays snowball without eliminating it

### Files to Modify

| File | Changes |
|------|---------|
| `engine/src/game/rules.ts` | Change Pop threshold from 3 to 5 in `getSciencePerTurn()` |
| `docs/rules/simple-civ_v0.96_rulebook.md` | Update ScholarKingdoms description |

---

## 4. Increase Smaller Map Sizes

### Problem Analysis

- **Tiny (12×8):** 20% stall rate, cramped for 2 civs
- **Small (16×12):** 10% stall rate
- **Standard (20×14):** 20% stall rate

Current dimensions:
```
Tiny:     12×8  =  96 tiles
Small:    16×12 = 192 tiles
Standard: 20×14 = 280 tiles
Large:    24×18 = 432 tiles
Huge:     32×24 = 768 tiles
```

### Proposed Changes

```
Tiny:     12×8  → 14×10 = 140 tiles (+46%)
Small:    16×12 → 18×14 = 252 tiles (+31%)
Standard: 20×14 → 22×16 = 352 tiles (+26%)
Large:    24×18 (unchanged)
Huge:     32×24 (unchanged)
```

**Constraints:**
- Tiny must remain significantly smaller than Small
- Small must remain significantly smaller than Standard
- Each size should have ~50% more tiles than the previous

### Implementation

```typescript
// engine/src/core/constants.ts
export const MAP_DIMS: Record<string, { w: number; h: number }> = {
    Tiny: { w: 14, h: 10 },      // Was 12×8
    Small: { w: 18, h: 14 },     // Was 16×12
    Standard: { w: 22, h: 16 },  // Was 20×14
    Large: { w: 24, h: 18 },     // Unchanged
    Huge: { w: 32, h: 24 },      // Unchanged
};
```

### Files to Modify

| File | Changes |
|------|---------|
| `engine/src/core/constants.ts` | Update `MAP_DIMS` for Tiny, Small, Standard |
| `docs/rules/simple-civ_v0.96_rulebook.md` | Update map size documentation |

---

## 5. Randomize Civ Selection

### Problem Analysis

Current simulation code uses a fixed order:
```typescript
const civs: CivName[] = [
    "ForgeClans",      // Always slot 1
    "ScholarKingdoms", // Always slot 2
    "RiverLeague",     // Slot 3 (Small+)
    "AetherianVanguard", // Slot 4 (Standard+)
    "StarborneSeekers",  // Slot 5 (Large+)
    "JadeCovenant",      // Slot 6 (Large+)
];
```

This means:
- Tiny maps: ALWAYS ForgeClans vs ScholarKingdoms
- Small maps: ALWAYS ForgeClans + ScholarKingdoms + RiverLeague
- Other civs only appear on larger maps

### Solution: Shuffle Civ Selection

#### For Simulations

```typescript
// engine/src/sim/comprehensive-analysis.ts
function civList(limit?: number, rng?: WorldRng): { id: string; civName: CivName; color: string; ai: boolean }[] {
    const civs: CivName[] = [
        "ForgeClans",
        "ScholarKingdoms",
        "RiverLeague",
        "AetherianVanguard",
        "StarborneSeekers",
        "JadeCovenant",
    ];
    
    // Shuffle if RNG provided
    if (rng) {
        rng.shuffle(civs);
    }
    
    const chosen = limit ? civs.slice(0, limit) : civs;
    const colors = ["#e25822", "#4b9be0", "#2fa866", "#8a4dd2", "#f4b400", "#888888"];
    
    // Assign colors based on civ, not position
    const civColors: Record<string, string> = {
        ForgeClans: "#e25822",
        ScholarKingdoms: "#4b9be0",
        RiverLeague: "#2fa866",
        AetherianVanguard: "#8a4dd2",
        StarborneSeekers: "#14b8a6",
        JadeCovenant: "#eab308",
    };
    
    return chosen.map((civ, idx) => ({
        id: `p${idx + 1}`,
        civName: civ,
        color: civColors[civ],
        ai: true,
    }));
}

// Usage in simulation
function runComprehensiveSimulation(seed = 42, mapSize: MapSize = "Huge", turnLimit = 200, playerCount?: number) {
    const rng = new WorldRng(seed);
    let state = generateWorld({ mapSize, players: civList(playerCount, rng), seed });
    // ...
}
```

#### For Game Setup (UI)

The game's new game setup should also randomize or let the player choose civs. This is a UI concern for the client.

### Files to Modify

| File | Changes |
|------|---------|
| `engine/src/sim/comprehensive-analysis.ts` | Shuffle civs using seed RNG |
| `engine/src/sim/ai-autoplay.ts` | Same shuffle logic |
| `engine/src/sim/city-growth-analysis.ts` | Same shuffle logic |
| `client/src/components/NewGameSetup.tsx` | (Optional) Add civ selection/randomization UI |

---

## 6. Add AI Razing Logic

### Problem Analysis

**0 cities razed** across 50 simulations. AI never razes because there's no logic for it.

### When Should AI Raze?

1. **City is indefensible:** Far from other cities, surrounded by enemies
2. **City provides no strategic value:** No good tiles, enemy territory
3. **City is a liability:** More units needed to defend than it's worth
4. **Conquest cleanup:** Raze small captured cities to focus on capitals

### Solution: Add `considerRazing()` Function

```typescript
// engine/src/game/ai/cities.ts - New function
export function considerRazing(state: GameState, playerId: string): GameState {
    let next = state;
    
    const playerCities = next.cities.filter(c => c.ownerId === playerId);
    const capitals = playerCities.filter(c => c.isCapital);
    
    // Never raze if we have <= 2 cities
    if (playerCities.length <= 2) return next;
    
    // Never raze our only capital
    if (capitals.length <= 1 && playerCities.length <= 2) return next;
    
    for (const city of playerCities) {
        // Never raze capitals
        if (city.isCapital) continue;
        
        // Never raze high-pop cities
        if (city.pop >= 4) continue;
        
        const shouldRaze = evaluateCityForRazing(city, playerId, next);
        
        if (shouldRaze) {
            next = tryAction(next, {
                type: "RazeCity",
                playerId,
                cityId: city.id,
            });
        }
    }
    
    return next;
}

function evaluateCityForRazing(city: City, playerId: string, state: GameState): boolean {
    // Calculate strategic value
    const factors = {
        // Distance from other owned cities (isolated = bad)
        isolation: calculateIsolation(city, playerId, state),
        // Nearby enemy strength
        threatLevel: calculateThreatLevel(city.coord, playerId, state),
        // Tile yields in territory
        economicValue: calculateEconomicValue(city, state),
        // Defensive capability
        defensibility: calculateDefensibility(city, playerId, state),
    };
    
    // Raze if:
    // - Very isolated (> 8 tiles from nearest friendly city)
    // - High threat (enemy city within 4 tiles and enemy military > our local military)
    // - Low economic value (< 3 F+P from workable tiles)
    // - Poor defensibility (no garrison, no City Ward, hills nearby for enemies)
    
    const razeScore = 
        (factors.isolation > 8 ? 2 : 0) +
        (factors.threatLevel > 1.5 ? 2 : 0) +
        (factors.economicValue < 3 ? 1 : 0) +
        (factors.defensibility < 0.5 ? 1 : 0);
    
    // Raze if score >= 3 (multiple bad factors)
    return razeScore >= 3;
}

function calculateIsolation(city: City, playerId: string, state: GameState): number {
    const friendlyCities = state.cities.filter(c => c.ownerId === playerId && c.id !== city.id);
    if (friendlyCities.length === 0) return Infinity;
    return Math.min(...friendlyCities.map(c => hexDistance(city.coord, c.coord)));
}

function calculateThreatLevel(coord: HexCoord, playerId: string, state: GameState): number {
    const enemies = state.players.filter(p => 
        p.id !== playerId && 
        state.diplomacy?.[playerId]?.[p.id] === DiplomacyState.War
    );
    
    if (enemies.length === 0) return 0;
    
    const enemyMilitary = state.units.filter(u =>
        enemies.some(e => e.id === u.ownerId) &&
        UNITS[u.type].domain !== "Civilian" &&
        hexDistance(coord, u.coord) <= 5
    );
    
    const ourMilitary = state.units.filter(u =>
        u.ownerId === playerId &&
        UNITS[u.type].domain !== "Civilian" &&
        hexDistance(coord, u.coord) <= 5
    );
    
    const enemyPower = enemyMilitary.reduce((sum, u) => sum + UNITS[u.type].atk + UNITS[u.type].def, 0);
    const ourPower = ourMilitary.reduce((sum, u) => sum + UNITS[u.type].atk + UNITS[u.type].def, 0);
    
    return ourPower > 0 ? enemyPower / ourPower : (enemyPower > 0 ? 10 : 0);
}

function calculateEconomicValue(city: City, state: GameState): number {
    // Sum F+P of workable tiles
    let total = 0;
    for (const tile of city.workedTiles) {
        const t = state.map.tiles.find(t => hexEquals(t.coord, tile));
        if (t) {
            const yields = getTileYields(t);
            total += yields.F + yields.P;
        }
    }
    return total;
}

function calculateDefensibility(city: City, playerId: string, state: GameState): number {
    let score = 0;
    
    // Has garrison?
    const hasGarrison = state.units.some(u => 
        u.ownerId === playerId && 
        hexEquals(u.coord, city.coord)
    );
    if (hasGarrison) score += 0.5;
    
    // Has City Ward?
    if (city.buildings.includes(BuildingType.CityWard)) score += 0.3;
    
    // City HP
    score += city.hp / 20 * 0.2;
    
    return score;
}
```

### Integration into Turn Sequence

```typescript
// engine/src/game/ai/turn-runner.ts
state = considerRazing(state, playerId); // After combat, before end turn
```

### Files to Modify

| File | Changes |
|------|---------|
| `engine/src/game/ai/cities.ts` | Add `considerRazing()`, `evaluateCityForRazing()`, helper functions |
| `engine/src/game/ai/turn-runner.ts` | Add `considerRazing()` to turn sequence |

---

## 7. Rebalance Army Unit Utilization

### Problem Analysis

- Only **68 Form Army projects** across 50 games (1.36/game)
- Army Doctrine is Engine era tech — by then, games are often decided
- Form Army projects compete with Progress chain for production
- Armies cost 15-20 production to form, then the base unit is gone

### Solution: Make Armies More Accessible and Attractive

#### Option A: Move Army Doctrine to Banner Era (Recommended)

```typescript
// engine/src/core/constants.ts
[TechId.ArmyDoctrine]: { 
    era: EraId.Banner,  // Was Engine
    cost: 50,           // Was 85
    prereqTechs: [TechId.FormationTraining], 
    unlock: { type: "Passive", key: "Enable Form Army projects" } 
},
```

**Rationale:**
- Armies become available mid-game, not late-game
- More time to benefit from army bonuses
- Still requires Formation Training (military focus)

#### Option B: Reduce Form Army Costs

```typescript
// engine/src/core/constants.ts
[ProjectId.FormArmy_SpearGuard]: { cost: 10 },  // Was 15
[ProjectId.FormArmy_BowGuard]: { cost: 10 },    // Was 15
[ProjectId.FormArmy_Riders]: { cost: 15 },      // Was 20
```

**Rationale:**
- Lower opportunity cost
- More attractive compared to building new units

#### Option C: Improve AI Army Priority

```typescript
// engine/src/game/ai/cities.ts - Modify buildPriorities
// Current: Form Army is only prioritized when at war
// Change: Form Army is prioritized when:
// - At war OR
// - We have 3+ of a unit type and ArmyDoctrine researched
// - Enemy military power is within 50% of ours

if (hasFormArmyTech) {
    const spearCount = next.units.filter(u => u.ownerId === playerId && u.type === UnitType.SpearGuard).length;
    const bowCount = next.units.filter(u => u.ownerId === playerId && u.type === UnitType.BowGuard).length;
    const ridersCount = next.units.filter(u => u.ownerId === playerId && u.type === UnitType.Riders).length;
    
    // Prioritize army formation if we have units to convert
    if (spearCount >= 2) priorities.unshift({ type: "Project", id: ProjectId.FormArmy_SpearGuard });
    if (bowCount >= 2) priorities.unshift({ type: "Project", id: ProjectId.FormArmy_BowGuard });
    if (ridersCount >= 2) priorities.unshift({ type: "Project", id: ProjectId.FormArmy_Riders });
}
```

### Recommendation

**Combine Options A + C:**
- Move Army Doctrine to Banner era (makes it available earlier)
- Improve AI priority logic (makes AI actually use it)

### Files to Modify

| File | Changes |
|------|---------|
| `engine/src/core/constants.ts` | Change ArmyDoctrine to Banner era |
| `engine/src/game/ai/cities.ts` | Improve Form Army priority logic |
| `docs/rules/simple-civ_v0.96_rulebook.md` | Update Army Doctrine era |

---

## Summary: Implementation Order

### Phase 1: Critical Fixes (High Impact)

1. **Fix Settler Escort Logic** — Will dramatically reduce settler deaths
2. **Nerf ScholarKingdoms** — Change Pop threshold from 3 to 5
3. **Buff AetherianVanguard** — Add Battle Hardened passive
4. **Buff JadeCovenant** — Add Bountiful Harvest passive

### Phase 2: Game Flow Improvements

5. **Increase Map Sizes** — Tiny/Small/Standard get bigger
6. **Randomize Civ Selection** — Shuffle civs for fair testing
7. **Move Army Doctrine to Banner** — Earlier army access

### Phase 3: AI Improvements

8. **Add AI Razing Logic** — Strategic city management
9. **Improve AI Army Priority** — Better army formation

---

## Testing Plan

After implementation:

1. **Run 100 simulations** (20 per map size) with randomized civs
2. **Target metrics:**
   - Settler survival rate: >50% (up from 7.5%)
   - Civ win rates: All civs between 10-25%
   - Victory type ratio: ~40% Conquest / ~50% Progress / ~10% Timeout
   - Victory rate: >90%
   - Army formations: >3 per game

---

## Files Summary

| File | Changes |
|------|---------|
| `engine/src/core/constants.ts` | Map sizes, Army Doctrine era, CIV_TRAITS |
| `engine/src/game/rules.ts` | ScholarKingdoms nerf, growth cost modifier, unit HP modifier |
| `engine/src/game/turn-lifecycle.ts` | Apply civ passives on spawn/found |
| `engine/src/game/ai/units.ts` | Rewrite settler escort logic |
| `engine/src/game/ai/turn-runner.ts` | Reorder turn sequence, add razing |
| `engine/src/game/ai/cities.ts` | Add razing logic, improve army priority |
| `engine/src/sim/*.ts` | Randomize civ selection |
| `docs/rules/simple-civ_v0.96_rulebook.md` | Update documentation |

---

*Document created: November 26, 2025*
*Based on comprehensive analysis of 50 AI vs AI simulations*

