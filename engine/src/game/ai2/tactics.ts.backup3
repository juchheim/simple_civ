import { DiplomacyState, GameState, Unit, UnitType } from "../../core/types.js";
import { hexDistance, hexEquals, getNeighbors } from "../../core/hex.js";
import { UNITS } from "../../core/constants.js";
import { findPath } from "../helpers/pathfinding.js";
import { tryAction } from "../ai/shared/actions.js";
import { getCombatPreviewUnitVsCity, getCombatPreviewUnitVsUnit } from "../helpers/combat-preview.js";
import { getAiMemoryV2, setAiMemoryV2 } from "./memory.js";
import { getAiProfileV2 } from "./rules.js";
import { selectFocusTargetV2 } from "./strategy.js";
import { pickBest } from "./util.js";

function isMilitary(u: Unit): boolean {
    return UNITS[u.type].domain !== "Civilian" && u.type !== UnitType.Scout && u.type !== UnitType.ArmyScout;
}

function isCapturer(u: Unit): boolean {
    return u.type === UnitType.SpearGuard || u.type === UnitType.ArmySpearGuard || u.type === UnitType.Titan;
}

function isSiege(u: Unit): boolean {
    return u.type === UnitType.BowGuard || u.type === UnitType.ArmyBowGuard;
}

function isRider(u: Unit): boolean {
    return u.type === UnitType.Riders || u.type === UnitType.ArmyRiders;
}

function hasReadyCapturerAdjacent(state: GameState, playerId: string, cityCoord: { q: number; r: number }): boolean {
    return state.units.some(u =>
        u.ownerId === playerId &&
        isMilitary(u) &&
        UNITS[u.type].canCaptureCity &&
        u.movesLeft > 0 &&
        hexDistance(u.coord, cityCoord) === 1
    );
}

function pickApproachTile(state: GameState, playerId: string, unit: Unit, cityCoord: { q: number; r: number }): { q: number; r: number } {
    // Pick an adjacent tile to the city that we can approach without stacking with friendly military.
    const neigh = getNeighbors(cityCoord);
    let best = neigh[0] ?? cityCoord;
    let bestScore = Number.POSITIVE_INFINITY;
    for (const n of neigh) {
        // Avoid any occupied tile (friendly or enemy); movement/capture needs clean adjacency.
        const occupied = state.units.some(u => hexEquals(u.coord, n));
        if (occupied) continue;
        const score = hexDistance(unit.coord, n);
        // Ensure it is actually reachable under current diplomacy/path rules.
        const path = findPath(unit.coord, n, unit, state);
        if (path.length === 0) continue;
        if (score < bestScore) {
            bestScore = score;
            best = n;
        }
    }
    return best;
}

function routeCityCapturesV2(state: GameState, playerId: string): GameState {
    let next = state;
    const capturable = next.cities.filter(c => c.ownerId !== playerId && c.hp <= 0);
    if (capturable.length === 0) return next;

    const captureUnits = next.units
        .filter(u => u.ownerId === playerId && u.movesLeft > 0 && isMilitary(u) && UNITS[u.type].canCaptureCity)
        .sort((a, b) => (b.type === UnitType.Titan ? 1 : 0) - (a.type === UnitType.Titan ? 1 : 0)); // prefer non-Titan first

    const assigned = new Set<string>();
    for (const city of capturable) {
        const candidates = captureUnits.filter(u => !assigned.has(u.id));
        if (candidates.length === 0) break;
        const best = pickBest(candidates, u => -hexDistance(u.coord, city.coord));
        const unit = best?.item;
        if (!unit) continue;
        // Don't try to move onto the city tile (garrison can block); move to an approach tile (adjacent),
        // then capture via Attack (handled by bestAttackForUnit).
        const live = next.units.find(u => u.id === unit.id);
        if (!live) continue;
        const approach = pickApproachTile(next, playerId, live, city.coord);
        const before = next;
        next = moveTowardAllMoves(next, playerId, unit.id, approach, 8);
        if (next !== before) assigned.add(unit.id);
    }
    return next;
}

function pickRallyCoord(state: GameState, target: { q: number; r: number }, desiredDist: number): { q: number; r: number } {
    // Pick a rally ring coord around the target that is reasonably close to our side.
    // (Bounded scan for performance.)
    let best = target;
    let bestScore = Number.POSITIVE_INFINITY;
    let scanned = 0;
    for (const t of state.map.tiles) {
        if (scanned++ > 900) break;
        const d = hexDistance(t.coord, target);
        if (d !== desiredDist) continue;
        // Prefer tiles that are not occupied by enemy city and are generally reachable.
        const score = Math.abs(t.coord.q - target.q) + Math.abs(t.coord.r - target.r);
        if (score < bestScore) {
            bestScore = score;
            best = t.coord;
        }
    }
    return best;
}

function pickRingCoordForUnit(
    state: GameState,
    playerId: string,
    unit: Unit,
    target: { q: number; r: number },
    desiredDist: number,
    scanLimit = 1000
): { q: number; r: number } {
    // Pick a coord at an exact distance ring around `target`, biased toward being reachable from `unit`,
    // and avoiding friendly military stacking.
    const candidates: { coord: { q: number; r: number }; score: number }[] = [];
    let scanned = 0;
    for (const t of state.map.tiles) {
        if (scanned++ > scanLimit) break;
        if (hexDistance(t.coord, target) !== desiredDist) continue;
        const occupied = state.units.some(u => hexEquals(u.coord, t.coord));
        if (occupied) continue;
        const score = hexDistance(unit.coord, t.coord);
        candidates.push({ coord: t.coord, score });
    }
    candidates.sort((a, b) => a.score - b.score);
    for (const c of candidates.slice(0, 30)) {
        const path = findPath(unit.coord, c.coord, unit, state);
        if (path.length > 0) return c.coord;
    }
    return target;
}

function runFocusSiegeAndCapture(state: GameState, playerId: string): GameState {
    let next = state;
    const enemies = warEnemyIds(next, playerId);
    if (enemies.size === 0) return next;

    const mem = getAiMemoryV2(next, playerId);
    const focusCity = mem.focusCityId ? next.cities.find(c => c.id === mem.focusCityId) : undefined;
    if (!focusCity || !enemies.has(focusCity.ownerId)) return next;

    // City attack range is 2; stage at 3 so units can step in to attack/capture quickly.
    const rally = pickRallyCoord(next, focusCity.coord, 3);

    const units = next.units
        .filter(u => u.ownerId === playerId && u.movesLeft > 0 && isMilitary(u))
        .filter(u => u.type !== UnitType.Titan); // Titan handled separately

    const capturers = units.filter(isCapturer);
    const siege = units.filter(isSiege);
    const riders = units.filter(isRider);
    const others = units.filter(u => !isCapturer(u) && !isSiege(u) && !isRider(u));

    // 1) Siege units: get to range 2 and shoot the focus city (do not stand adjacent).
    for (const u of siege) {
        const live = next.units.find(x => x.id === u.id);
        if (!live || live.movesLeft <= 0) continue;
        const dist = hexDistance(live.coord, focusCity.coord);
        if (dist <= 2) continue; // close enough, attack pass will prefer city now
        const siegeRing = pickRingCoordForUnit(next, playerId, live, focusCity.coord, 2, 1200);
        next = moveToward(next, playerId, live, siegeRing);
    }

    // 2) Capturers: stay staged until the city is low, then move in and capture.
    for (const u of capturers) {
        const live = next.units.find(x => x.id === u.id);
        if (!live || live.movesLeft <= 0) continue;
        const dist = hexDistance(live.coord, focusCity.coord);

        // If adjacent, stop (attack pass will handle capture attempts).
        if (dist === 1) continue;

        // If city is already at/under 0 (somehow) rush capture.
        if (focusCity.hp <= 0) {
            next = moveToward(next, playerId, live, focusCity.coord);
            continue;
        }

        // FIX #3: Route capturers to cities under ACTIVE SIEGE (not just 0 HP).
        // If city is below 60% HP, it's being bombarded - get capturers in position NOW.
        const hpPercent = focusCity.maxHp ? focusCity.hp / focusCity.maxHp : 1;
        const isUnderSiege = hpPercent <= 0.6;

        // Once the city is low, under siege, or it's a capital, step onto an approach tile so we can capture immediately when it hits 0.
        if (focusCity.isCapital || focusCity.hp <= 12 || isUnderSiege) {
            const approach = pickApproachTile(next, playerId, live, focusCity.coord);
            next = moveToward(next, playerId, live, approach);
        } else {
            // Otherwise stage at rally until siege has softened it.
            next = moveToward(next, playerId, live, rally);
        }
    }

    // 3) Riders: never outrunâ€”keep them within 2 tiles of the nearest capturer/siege.
    const anchorUnits = [...capturers, ...siege].map(u => next.units.find(x => x.id === u.id)).filter(Boolean) as Unit[];
    for (const u of riders) {
        const live = next.units.find(x => x.id === u.id);
        if (!live || live.movesLeft <= 0) continue;
        const nearestAnchorDist = anchorUnits.length
            ? Math.min(...anchorUnits.map(a => hexDistance(a.coord, live.coord)))
            : 0;
        if (nearestAnchorDist > 2) {
            // Move only one step toward rally (single-step pacing)
            next = moveToward(next, playerId, live, rally);
        }
    }

    // 4) Others: follow to rally.
    for (const u of others) {
        const live = next.units.find(x => x.id === u.id);
        if (!live || live.movesLeft <= 0) continue;
        next = moveToward(next, playerId, live, rally);
    }

    return next;
}

function warEnemyIds(state: GameState, playerId: string): Set<string> {
    const ids = new Set<string>();
    for (const p of state.players) {
        if (p.id === playerId || p.isEliminated) continue;
        if (state.diplomacy?.[playerId]?.[p.id] === "War") ids.add(p.id);
    }
    return ids;
}

function cityValue(state: GameState, playerId: string, city: any): number {
    const profile = getAiProfileV2(state, playerId);
    let v = 20;
    if (city.isCapital) v += 35 * profile.titan.capitalHunt;
    const hpFrac = city.maxHp ? city.hp / city.maxHp : 1;
    v += (1 - hpFrac) * 18 * profile.titan.finisher;
    if (city.hp <= 0) v += 40;
    return v;
}

function unitValue(u: Unit): number {
    if (String(u.type).startsWith("Army")) return 18;
    if (u.type === UnitType.Titan) return 50;
    if (u.type === UnitType.Riders) return 12;
    if (u.type === UnitType.BowGuard) return 11;
    if (u.type === UnitType.SpearGuard) return 10;
    if (u.type === UnitType.Scout || u.type === UnitType.ArmyScout) return 4;
    if (u.type === UnitType.Settler) return 30;
    return 8;
}

function attackScoreVsUnit(state: GameState, playerId: string, attacker: Unit, defender: Unit): number {
    const profile = getAiProfileV2(state, playerId);
    const preview = getCombatPreviewUnitVsUnit(state, attacker, defender);
    const dmg = preview.estimatedDamage.avg;
    const ret = preview.returnDamage?.avg ?? 0;
    const kill = dmg >= defender.hp ? 1 : 0;
    const suicide = ret >= attacker.hp ? 1 : 0;

    const base = dmg * 2 + kill * (40 + unitValue(defender) * 2);
    const riskPenalty = (ret * 1.7) * (1 - profile.tactics.riskTolerance);
    const suicidePenalty = suicide ? 200 : 0;
    return base - riskPenalty - suicidePenalty;
}

function attackScoreVsCity(state: GameState, playerId: string, attacker: Unit, city: any): number {
    const profile = getAiProfileV2(state, playerId);
    const preview = getCombatPreviewUnitVsCity(state, attacker, city);
    const dmg = preview.estimatedDamage.avg;
    const ret = preview.returnDamage?.avg ?? 0;

    const wouldDropToZero = city.hp - dmg <= 0;
    const canCaptureNow = wouldDropToZero && UNITS[attacker.type].canCaptureCity && hexDistance(attacker.coord, city.coord) === 1;
    const attackerCanCapture = !!UNITS[attacker.type].canCaptureCity;
    const followUpCapture = hasReadyCapturerAdjacent(state, playerId, city.coord);

    const base = dmg * 2.5 + cityValue(state, playerId, city);
    const captureBonus = canCaptureNow ? 420 : 0;
    let riskPenalty = (ret * 1.8) * (1 - profile.tactics.riskTolerance);
    const capitalBonus = city.isCapital ? 180 : 0;

    // Capital assaults must be less risk-averse, otherwise capitals never fall and we stall to turn limit.
    if (city.isCapital) {
        riskPenalty *= 0.6;
        if (canCaptureNow) riskPenalty *= 0.2;
    }

    // Critical anti-stall rule:
    // If a non-capturer (or a capturer not currently adjacent) would reduce a city to 0,
    // penalize unless we have an immediate adjacent capturer ready to step in this turn.
    // This prevents bowguards from "sniping" cities to 0 and leaving them uncaptured for many turns.
    let lethalNoCapturePenalty = 0;
    if (wouldDropToZero && !canCaptureNow && !followUpCapture) {
        lethalNoCapturePenalty = attackerCanCapture ? 350 : 800;
    }

    return base + captureBonus + capitalBonus - riskPenalty - lethalNoCapturePenalty;
}

function bestAttackForUnit(state: GameState, playerId: string, unit: Unit): { action: any; score: number } | null {
    const enemies = warEnemyIds(state, playerId);
    if (enemies.size === 0) return null;
    const rng = UNITS[unit.type].rng;
    const mem = getAiMemoryV2(state, playerId);
    const focusCity = mem.focusCityId ? state.cities.find(c => c.id === mem.focusCityId) : undefined;
    const focusEnemy = focusCity && enemies.has(focusCity.ownerId) ? focusCity : undefined;

    // Capture NOW if adjacent to a 0-HP enemy city (legacy captureIfPossible behavior).
    if (UNITS[unit.type].canCaptureCity) {
        const adjZero = state.cities.find(c =>
            enemies.has(c.ownerId) &&
            c.hp <= 0 &&
            hexDistance(unit.coord, c.coord) === 1
        );
        if (adjZero) {
            return {
                action: { type: "Attack", playerId, attackerId: unit.id, targetType: "City", targetId: adjZero.id },
                score: 999999,
            };
        }
    }

    const unitTargets = state.units
        .filter(u => enemies.has(u.ownerId))
        .filter(u => hexDistance(unit.coord, u.coord) <= rng)
        .map(u => ({
            kind: "Unit" as const,
            target: u,
            score: attackScoreVsUnit(state, playerId, unit, u),
        }));

    const cityTargets = state.cities
        .filter(c => enemies.has(c.ownerId))
        .filter(c => hexDistance(unit.coord, c.coord) <= rng)
        .map(c => ({
            kind: "City" as const,
            target: c,
            score: (() => {
                let s = attackScoreVsCity(state, playerId, unit, c);
                // Siege priority: push the focus city hard so wars actually convert into captures.
                if (focusEnemy && c.id === focusEnemy.id) {
                    if (UNITS[unit.type].canCaptureCity) s += 200;
                    if (UNITS[unit.type].rng > 1) s += 220;
                    if (unit.type === UnitType.Titan) s += 350;
                }
                return s;
            })(),
        }));

    const best = pickBest([...unitTargets, ...cityTargets], t => t.score);
    if (!best) return null;

    const tgt = best.item;
    if (tgt.kind === "Unit") {
        return { action: { type: "Attack", playerId, attackerId: unit.id, targetType: "Unit", targetId: tgt.target.id }, score: tgt.score };
    }
    return { action: { type: "Attack", playerId, attackerId: unit.id, targetType: "City", targetId: tgt.target.id }, score: tgt.score };
}

function moveToward(state: GameState, playerId: string, unit: Unit, dest: { q: number; r: number }): GameState {
    const path = findPath(unit.coord, dest, unit, state);
    if (path.length === 0) return state;
    const step = path[0];

    const occupiedFriendlyMil = state.units.some(u =>
        u.ownerId === playerId &&
        u.id !== unit.id &&
        isMilitary(u) &&
        hexEquals(u.coord, step)
    );
    if (occupiedFriendlyMil) {
        const curDist = hexDistance(unit.coord, dest);
        const candidates = getNeighbors(unit.coord)
            .filter(n => hexDistance(n, dest) < curDist)
            .filter(n => !state.units.some(u => u.ownerId === playerId && isMilitary(u) && hexEquals(u.coord, n)))
            .sort((a, b) => hexDistance(a, dest) - hexDistance(b, dest));
        for (const alt of candidates) {
            const movedAlt = tryAction(state, { type: "MoveUnit", playerId, unitId: unit.id, to: alt });
            if (movedAlt !== state) return movedAlt;
        }
        return state;
    }

    return tryAction(state, { type: "MoveUnit", playerId, unitId: unit.id, to: step });
}

function moveTowardAllMoves(state: GameState, playerId: string, unitId: string, dest: { q: number; r: number }, maxSteps = 6): GameState {
    let next = state;
    let steps = 0;
    while (steps++ < maxSteps) {
        const unit = next.units.find(u => u.id === unitId);
        if (!unit || unit.movesLeft <= 0) return next;
        if (hexDistance(unit.coord, dest) === 0) return next;
        const before = next;
        next = moveToward(next, playerId, unit, dest);
        if (next === before) return next;
    }
    return next;
}

function findEngagementPath(start: { q: number; r: number }, target: { q: number; r: number }, unit: Unit, state: GameState): { q: number; r: number }[] | null {
    const direct = findPath(start, target, unit, state);
    if (direct && direct.length > 0) return direct;
    const neighbors = getNeighbors(target).sort((a, b) => hexDistance(a, start) - hexDistance(b, start));
    for (const n of neighbors) {
        if (hexEquals(n, start)) return [];
        const path = findPath(start, n, unit, state);
        if (path && path.length > 0) return path;
    }
    return null;
}

function nearestFriendlyCity(state: GameState, playerId: string, from: { q: number; r: number }): { q: number; r: number } | null {
    const cities = state.cities.filter(c => c.ownerId === playerId);
    if (cities.length === 0) return null;
    let best = cities[0]!.coord;
    let bestDist = hexDistance(from, best);
    for (const c of cities) {
        const d = hexDistance(from, c.coord);
        if (d < bestDist) {
            bestDist = d;
            best = c.coord;
        }
    }
    return best;
}

function retreatIfNeeded(state: GameState, playerId: string, unit: Unit): GameState {
    const profile = getAiProfileV2(state, playerId);
    if (!isMilitary(unit)) return state;
    const hpFrac = unit.maxHp ? unit.hp / unit.maxHp : (unit.hp / UNITS[unit.type].hp);

    // FIX #5: Reduce retreat threshold during active sieges.
    // Units should stay in the fight when we're close to capturing a city.
    const mem = getAiMemoryV2(state, playerId);
    const focusCity = mem.focusCityId ? state.cities.find(c => c.id === mem.focusCityId) : undefined;
    const inActiveSiege = focusCity && focusCity.ownerId !== playerId && hexDistance(unit.coord, focusCity.coord) <= 4;

    // During sieges, units are 50% less likely to retreat (effectively halves the HP threshold).
    const effectiveRetreatFrac = inActiveSiege
        ? profile.tactics.retreatHpFrac * 0.5
        : profile.tactics.retreatHpFrac;

    if (hpFrac >= effectiveRetreatFrac) return state;

    // Siege commitment: if we're committed to a capital siege, don't peel off at moderate HP.
    if (focusCity && focusCity.isCapital && focusCity.ownerId !== playerId) {
        const nearFocus = hexDistance(unit.coord, focusCity.coord) <= 4;
        if (nearFocus && profile.tactics.siegeCommitment >= 0.7 && hpFrac >= 0.2) {
            return state;
        }
    }

    const enemies = warEnemyIds(state, playerId);
    if (enemies.size === 0) return state;
    const nearbyThreat = state.units.some(u => enemies.has(u.ownerId) && hexDistance(u.coord, unit.coord) <= 2);
    if (!nearbyThreat) return state;

    const cities = state.cities.filter(c => c.ownerId === playerId);
    const safeCity = cities.sort((a, b) => hexDistance(a.coord, unit.coord) - hexDistance(b.coord, unit.coord))[0];
    if (!safeCity) return state;

    return moveToward(state, playerId, unit, safeCity.coord);
}

function runTitanAgent(state: GameState, playerId: string): GameState {
    let next = state;
    const titan = next.units.find(u => u.ownerId === playerId && u.type === UnitType.Titan);
    if (!titan) return next;
    const enemies = warEnemyIds(next, playerId);
    if (enemies.size === 0) return next;

    const profile = getAiProfileV2(next, playerId);
    const memory = getAiMemoryV2(next, playerId);
    const enemyCities = next.cities.filter(c => enemies.has(c.ownerId));
    if (enemyCities.length === 0) return next;

    // Align Titan with the main siege focus if we have one (prevents Titan wandering to a different target
    // while the deathball captures cities elsewhere).
    const focusCity = memory.focusCityId ? next.cities.find(c => c.id === memory.focusCityId) : undefined;
    if (focusCity && enemies.has(focusCity.ownerId)) {
        next = setAiMemoryV2(next, playerId, { ...memory, titanFocusCityId: focusCity.id });
    }

    let targetCityId = memory.titanFocusCityId;
    if (targetCityId) {
        const stillValid = enemyCities.some(c => c.id === targetCityId);
        if (!stillValid) targetCityId = undefined;
    }

    if (!targetCityId) {
        const best = pickBest(enemyCities, c => {
            const dist = hexDistance(titan.coord, c.coord);
            const capital = c.isCapital ? 1 : 0;
            const finish = c.hp <= 0 ? 1 : 0;
            const hpFrac = c.maxHp ? c.hp / c.maxHp : 1;
            const momentum = -dist * (1.2 + profile.titan.momentum);
            return (capital * 25 * profile.titan.capitalHunt) + (finish * 30 * profile.titan.finisher) + ((1 - hpFrac) * 18) + momentum;
        });
        targetCityId = best?.item?.id;
    }

    if (!targetCityId) return next;
    next = setAiMemoryV2(next, playerId, { ...memory, titanFocusCityId: targetCityId });

    const targetCity = next.cities.find(c => c.id === targetCityId);
    if (!targetCity) return next;

    // Titan constraints were too strict and were effectively neutering the unit:
    // - It was frequently waiting for 3+ support units (based on forceConcentration),
    // - and it was using only 1 movement even though Titan has move=2.
    //
    // New behavior:
    // - AetherianVanguard Titan is allowed to spearhead (minimal support requirement),
    // - uses ALL remaining movement each turn toward its target,
    // - avoids only "pure suicide" attacks unless the attack would capture a city.
    const titanHpFrac = titan.maxHp ? titan.hp / titan.maxHp : (titan.hp / UNITS[titan.type].hp);
    const onFriendlyCity = next.cities.some(c => c.ownerId === playerId && hexEquals(c.coord, titan.coord));
    if (titanHpFrac < 0.2 && !onFriendlyCity) {
        const safe = nearestFriendlyCity(next, playerId, titan.coord);
        if (safe) {
            return moveTowardAllMoves(next, playerId, titan.id, safe, 6);
        }
    }
    const supportCount = next.units.filter(u =>
        u.ownerId === playerId &&
        isMilitary(u) &&
        u.type !== UnitType.Titan &&
        hexDistance(u.coord, titan.coord) <= 2
    ).length;
    const isAetherian = profile.civName === "AetherianVanguard";
    const requiredSupport = isAetherian ? 1 : (titanHpFrac < 0.55 ? 2 : 1);
    const allowDeepPush = isAetherian || supportCount >= requiredSupport;

    // Legacy lesson: Titan must handle blockers. Prefer pathing to an engagement tile (adjacent to city),
    // and if movement fails due to occupancy, clear the blocking unit then resume sieging.
    let safety = 0;
    while (safety++ < 8) {
        const live = next.units.find(u => u.id === titan.id);
        const cityNow = next.cities.find(c => c.id === targetCityId);
        if (!live || !cityNow) return next;
        if (live.movesLeft <= 0) return next;

        const dist = hexDistance(live.coord, cityNow.coord);

        // 1) Immediate capture if city is already at 0 and we are adjacent.
        if (cityNow.hp <= 0 && dist === 1 && UNITS[live.type].canCaptureCity) {
            const moved = tryAction(next, { type: "MoveUnit", playerId, unitId: live.id, to: cityNow.coord });
            if (moved !== next) {
                next = moved;
                continue;
            }
        }

        // 2) If not adjacent, move toward an engagement tile (not the city tile itself).
        if (dist > 1) {
            const path = findEngagementPath(live.coord, cityNow.coord, live, next);
            if (path && path.length > 0) {
                const step = path[0];
                const moved = tryAction(next, { type: "MoveUnit", playerId, unitId: live.id, to: step });
                if (moved !== next) {
                    next = moved;
                    continue;
                }
                // Movement failed: attempt to clear a blocking unit (prefer the unit on our intended step).
                if (!live.hasAttacked) {
                    const blocker =
                        next.units.find(u => u.ownerId !== playerId && hexEquals(u.coord, step)) ??
                        next.units.find(u => u.ownerId !== playerId && hexDistance(u.coord, live.coord) <= UNITS[live.type].rng);
                    if (blocker) {
                        const attacked = tryAction(next, { type: "Attack", playerId, attackerId: live.id, targetType: "Unit", targetId: blocker.id });
                        if (attacked !== next) {
                            next = attacked;
                            continue;
                        }
                    }
                }
                // Can't move, can't clear: give up this loop.
                break;
            } else {
                // No path to engagement: try to clear *any* adjacent enemy, otherwise drop target and re-pick next turn.
                if (!live.hasAttacked) {
                    const blocker = next.units.find(u => u.ownerId !== playerId && hexDistance(u.coord, live.coord) <= UNITS[live.type].rng);
                    if (blocker) {
                        const attacked = tryAction(next, { type: "Attack", playerId, attackerId: live.id, targetType: "Unit", targetId: blocker.id });
                        if (attacked !== next) {
                            next = attacked;
                            continue;
                        }
                    }
                }
                // If we can't path (rare in real games, common in unit tests with empty maps),
                // keep the selected target so we don't oscillate or clear memory incorrectly.
                break;
            }
        }

        // 3) Attack city if in range.
        if (!live.hasAttacked && dist <= UNITS[live.type].rng && cityNow.hp > 0) {
            const preview = getCombatPreviewUnitVsCity(next, live, cityNow);
            const ret = preview.returnDamage?.avg ?? 0;
            const wouldDie = ret >= live.hp;
            const dmg = preview.estimatedDamage.avg;
            const wouldCapture = (cityNow.hp - dmg) <= 0 && dist === 1;
            if (wouldCapture || !wouldDie || profile.tactics.riskTolerance >= 0.8) {
                const attacked = tryAction(next, { type: "Attack", playerId, attackerId: live.id, targetType: "City", targetId: cityNow.id });
                if (attacked !== next) {
                    next = attacked;
                    continue;
                }
            }
        }

        break;
    }

    const liveTitan = next.units.find(u => u.id === titan.id);
    if (!liveTitan || liveTitan.movesLeft <= 0) return next;

    if (!allowDeepPush) {
        // Non-Aetherian Titans (if any) or edge cases: don't run off alone when badly hurt.
        if (titanHpFrac < 0.55) return next;
    }

    // If we still have moves after attacking, keep closing to an engagement tile.
    const cityNow = next.cities.find(c => c.id === targetCityId);
    if (!cityNow) return next;
    const path = findEngagementPath(liveTitan.coord, cityNow.coord, liveTitan, next);
    const dest = (path && path.length > 0) ? path[path.length - 1] : cityNow.coord;
    next = moveTowardAllMoves(next, playerId, liveTitan.id, dest, 8);
    return next;
}

export function runTacticsV2(state: GameState, playerId: string): GameState {
    let next = state;

    // Ensure focus target exists (sets memory).
    const focused = selectFocusTargetV2(next, playerId);
    next = focused.state;

    // Retreat pass.
    const unitsForRetreat = next.units.filter(u => u.ownerId === playerId && u.movesLeft > 0 && isMilitary(u) && u.type !== UnitType.Titan);
    for (const unit of unitsForRetreat) {
        const live = next.units.find(u => u.id === unit.id);
        if (!live || live.movesLeft <= 0) continue;
        next = retreatIfNeeded(next, playerId, live);
    }

    // Attack pass (exclude Titan: Titan is a dedicated agent; mixing it into generic scoring reduces captures and increases thrash).
    const attackers = next.units.filter(u => u.ownerId === playerId && !u.hasAttacked && isMilitary(u) && u.type !== UnitType.Titan);
    for (const unit of attackers) {
        const live = next.units.find(u => u.id === unit.id);
        if (!live || live.hasAttacked) continue;
        const best = bestAttackForUnit(next, playerId, live);
        if (best && best.score > 0) {
            next = tryAction(next, best.action);
        }
    }

    // Immediate capture routing: if any enemy city is at 0 HP, send a capturer to take it now.
    // This is a key missing piece vs Legacy (`routeCityCaptures`) and is required to close out wars.
    next = routeCityCapturesV2(next, playerId);

    // Titan agent (separate so it doesn't get blocked by generic movement/attacks).
    next = runTitanAgent(next, playerId);

    // Main siege/capture behavior: coordinate a real combined-arms push on the focused city.
    next = runFocusSiegeAndCapture(next, playerId);

    const enemies = warEnemyIds(next, playerId);
    const inWar = enemies.size > 0;

    const memory = getAiMemoryV2(next, playerId);
    const focusCity = memory.focusCityId ? next.cities.find(c => c.id === memory.focusCityId) : undefined;
    if (!focusCity) return next;

    const profile = getAiProfileV2(next, playerId);

    // Pre-war rally: if we have a focus target and can initiate wars, start staging a strike group even while at peace.
    // This avoids a deadlock where diplomacy wants staged forces before declaring but no one ever moves toward the front.
    const focusedTargetId = memory.focusTargetPlayerId;
    const stanceToFocus = focusedTargetId ? (next.diplomacy?.[playerId]?.[focusedTargetId] ?? DiplomacyState.Peace) : DiplomacyState.Peace;
    const canPreWarRally =
        !inWar &&
        !!focusedTargetId &&
        stanceToFocus === DiplomacyState.Peace &&
        profile.diplomacy.canInitiateWars &&
        profile.tactics.forceConcentration >= 0.65;

    // Force concentration / staging: if we don't have enough units near the focus city, rally at a staging ring instead of trickling in.
    const requiredNear = Math.max(2, Math.ceil(profile.tactics.forceConcentration * 4));
    const nearCount = next.units.filter(u =>
        u.ownerId === playerId &&
        isMilitary(u) &&
        u.type !== UnitType.Titan &&
        hexDistance(u.coord, focusCity.coord) <= 5
    ).length;
    const shouldStage = (nearCount < requiredNear) && (profile.tactics.forceConcentration >= 0.65);

    const pickStagingCoord = (unit: Unit): { q: number; r: number } => {
        const desiredDist = 5;
        let best = focusCity.coord;
        let bestScore = Number.POSITIVE_INFINITY;
        // Scan a limited subset (map tiles are not huge; still keep it bounded).
        let scanned = 0;
        for (const t of next.map.tiles) {
            if (scanned++ > 600) break;
            const dCity = hexDistance(t.coord, focusCity.coord);
            if (dCity !== desiredDist) continue;
            const dUnit = hexDistance(t.coord, unit.coord);
            if (dUnit < bestScore) {
                bestScore = dUnit;
                best = t.coord;
            }
        }
        return best;
    };

    const cityTiles = new Set(next.cities.filter(c => c.ownerId === playerId).map(c => `${c.coord.q},${c.coord.r}`));
    const movers = next.units
        .filter(u =>
            u.ownerId === playerId &&
            u.movesLeft > 0 &&
            isMilitary(u) &&
            u.type !== UnitType.Titan &&
            !cityTiles.has(`${u.coord.q},${u.coord.r}`) // don't pull garrisons off cities
        )
        .sort((a, b) => hexDistance(a.coord, focusCity.coord) - hexDistance(b.coord, focusCity.coord));

    // If we're not at war yet, move a real strike group (not 2 units) so we can actually declare and capture fast.
    const maxPreWarMovers = canPreWarRally ? Math.max(8, requiredNear - nearCount) : movers.length;
    let movedCount = 0;

    for (const unit of movers) {
        const live = next.units.find(u => u.id === unit.id);
        if (!live || live.movesLeft <= 0) continue;
        if (hexDistance(live.coord, focusCity.coord) <= UNITS[live.type].rng) continue; // already in range-ish
        const dest = (shouldStage || canPreWarRally) ? pickStagingCoord(live) : focusCity.coord;

        // Riders are fast and tend to outrun the stack. While staging, keep them to single-step pacing.
        const isRider = live.type === UnitType.Riders || live.type === UnitType.ArmyRiders;
        const before = next;
        next = isRider ? moveToward(before, playerId, live, dest) : moveToward(before, playerId, live, dest);
        if (next !== before) {
            movedCount += 1;
            if (canPreWarRally && movedCount >= maxPreWarMovers) break;
        }
    }

    return next;
}


